# Daily Review Plugin Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build an Obsidian plugin for daily note review with single-note focus modal, random order, and flexible filtering (time range, tags, folders).

**Architecture:** Native Obsidian API with TypeScript. Four core modules: main (entry), ReviewModal (UI), Settings (configuration), NoteFilter (filtering logic). Performance optimized by deferring content reading until after candidate selection.

**Tech Stack:** TypeScript, Obsidian Plugin API, ESBuild (standard Obsidian plugin build)

---

## Prerequisites

### Task 0: Project Setup

**Files:**
- Create: `manifest.json`
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `esbuild.config.mjs`
- Create: `.gitignore`
- Create: `main.ts` (entry point)

**Step 1: Create manifest.json**

```json
{
  "id": "daily-review",
  "name": "Daily Review",
  "version": "0.0.1",
  "minAppVersion": "0.15.0",
  "description": "Review your notes with a focused, random daily review session",
  "author": "Your Name",
  "authorUrl": "https://github.com/yourusername",
  "isDesktopOnly": false
}
```

**Step 2: Create package.json**

```json
{
  "name": "daily-review",
  "version": "0.0.1",
  "description": "Daily Review Plugin for Obsidian",
  "main": "main.js",
  "scripts": {
    "dev": "node esbuild.config.mjs",
    "build": "tsc -noEmit -skipLibCheck && node esbuild.config.mjs production"
  },
  "keywords": [],
  "author": "Your Name",
  "license": "MIT",
  "devDependencies": {
    "@types/node": "^16.11.6",
    "@typescript-eslint/eslint-plugin": "5.29.0",
    "@typescript-eslint/parser": "5.29.0",
    "builtin-modules": "3.3.0",
    "esbuild": "0.17.3",
    "obsidian": "latest",
    "tslib": "2.4.0",
    "typescript": "4.7.4"
  }
}
```

**Step 3: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "inlineSourceMap": true,
    "inlineSources": true,
    "module": "ESNext",
    "target": "ES6",
    "allowJs": true,
    "noImplicitAny": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "isolatedModules": true,
    "strictNullChecks": true,
    "lib": ["DOM", "ES5", "ES6", "ES7"]
  },
  "include": ["**/*.ts"]
}
```

**Step 4: Create esbuild.config.mjs**

```javascript
import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === 'production');

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ['main.ts'],
  bundle: true,
  external: [
    'obsidian',
    'electron',
    '@codemirror/autocomplete',
    '@codemirror/closebrackets',
    '@codemirror/collab',
    '@codemirror/commands',
    '@codemirror/comment',
    '@codemirror/fold',
    '@codemirror/gutter',
    '@codemirror/highlight',
    '@codemirror/history',
    '@codemirror/language',
    '@codemirror/lint',
    '@codemirror/matchbrackets',
    '@codemirror/panel',
    '@codemirror/rangeset',
    '@codemirror/rectangular-selection',
    '@codemirror/search',
    '@codemirror/state',
    '@codemirror/stream-parser',
    '@codemirror/text',
    '@codemirror/tooltip',
    '@codemirror/view',
    ...builtins],
  format: 'cjs',
  target: 'es2018',
  logLevel: "info",
  sourcemap: prod ? false : 'inline',
  treeShaking: true,
  outfile: 'main.js',
});

if (prod) {
  await context.rebuild();
  process.exit(0);
} else {
  await context.watch();
}
```

**Step 5: Create .gitignore**

```
.node_modules/
main.js
main.js.map
*.log
.DS_Store
```

**Step 6: Create initial main.ts**

```typescript
import { Plugin } from 'obsidian';

export default class DailyReviewPlugin extends Plugin {
  async onload() {
    console.log('Loading Daily Review plugin');
  }

  onunload() {
    console.log('Unloading Daily Review plugin');
  }
}
```

**Step 7: Install dependencies**

```bash
npm install
```

**Step 8: Verify build works**

```bash
npm run dev
```

Expected: Build succeeds with "main.js" generated

**Step 9: Commit**

```bash
git add .
git commit -m "feat: initialize Obsidian plugin project structure"
```

---

## Module 1: Type Definitions

### Task 1: Create Type Definitions

**Files:**
- Create: `src/types.ts`

**Step 1: Create type definitions file**

```typescript
import { TFile } from "obsidian";

export type TimeRange = 'today' | 'week' | 'month' | 'quarter' | 'all';

export interface DailyReviewSettings {
  timeRange: TimeRange;
  reviewCount: number;
  includeTags: string[];
  excludeTags: string[];
  excludeFolders: string[];
  includeSubfolders: boolean;
}

export const DEFAULT_SETTINGS: DailyReviewSettings = {
  timeRange: 'month',
  reviewCount: 10,
  includeTags: [],
  excludeTags: ['#template', '#archive'],
  excludeFolders: ['Templates', 'Archive'],
  includeSubfolders: true,
};

export interface NoteCandidate {
  file: TFile;
  tags: string[];
  title: string;
}
```

**Step 2: Commit**

```bash
git add src/types.ts
git commit -m "feat: add type definitions for settings and note candidates"
```

---

## Module 2: Note Filtering Logic

### Task 2: Implement Time Range Filter

**Files:**
- Create: `src/NoteFilter.ts`
- Create: `tests/NoteFilter.test.ts` (manual testing file for reference)

**Step 1: Create NoteFilter class skeleton**

```typescript
import { TFile, Vault } from "obsidian";
import { TimeRange, DailyReviewSettings } from "./types";

export class NoteFilter {
  constructor(
    private vault: Vault,
    private settings: DailyReviewSettings
  ) {}

  // Get timestamp cutoff for time range
  private getTimeCutoff(): number {
    const now = Date.now();
    const msPerDay = 24 * 60 * 60 * 1000;

    switch (this.settings.timeRange) {
      case 'today':
        return now - msPerDay;
      case 'week':
        return now - (7 * msPerDay);
      case 'month':
        return now - (30 * msPerDay);
      case 'quarter':
        return now - (90 * msPerDay);
      case 'all':
        return 0;
      default:
        return 0;
    }
  }
}
```

**Step 2: Add method to check if file is in time range**

Add to NoteFilter class:

```typescript
  // Check if file matches time range
  private isInTimeRange(file: TFile): boolean {
    const cutoff = this.getTimeCutoff();
    if (cutoff === 0) return true; // 'all' means no filter

    // Try to get date from filename (e.g., 2024-01-15.md)
    const dateMatch = file.basename.match(/^(\d{4}-\d{2}-\d{2})/);
    if (dateMatch) {
      const fileDate = new Date(dateMatch[1]).getTime();
      return fileDate >= cutoff;
    }

    // Fall back to file modification time
    return file.stat.mtime >= cutoff;
  }
```

**Step 3: Add method to check if file is in excluded folder**

Add to NoteFilter class:

```typescript
  // Check if file is in excluded folder
  private isExcludedFolder(file: TFile): boolean {
    return this.settings.excludeFolders.some(folder => {
      const normalizedPath = file.path.replace(/\\/g, '/');
      const folderPath = folder.trim().replace(/\\/g, '/');

      // Check if path starts with folder (with or without trailing slash)
      return normalizedPath.startsWith(folderPath) ||
             normalizedPath.startsWith(folderPath + '/');
    });
  }
```

**Step 4: Commit**

```bash
git add src/NoteFilter.ts
git commit -m "feat: add time range and folder filtering logic"
```

### Task 3: Implement Tag Extraction

**Files:**
- Modify: `src/NoteFilter.ts`

**Step 1: Add method to extract tags from file content**

Add to NoteFilter class:

```typescript
  // Extract tags from file content
  async getTagsFromFile(file: TFile): Promise<string[]> {
    const content = await this.vault.read(file);
    const tags = new Set<string>();

    // Extract inline tags (e.g., #tag)
    const inlineTagRegex = /(?<!\w)#([\p{L}\p{N}_-]+)/gu;
    let match;
    while ((match = inlineTagRegex.exec(content)) !== null) {
      tags.add('#' + match[1]);
    }

    // Extract tags from frontmatter YAML
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const frontmatterMatch = content.match(frontmatterRegex);
    if (frontmatterMatch) {
      const yamlContent = frontmatterMatch[1];

      // Match tags: array format
      const arrayTagRegex = /tags:\s*\[(.*?)\]/;
      const arrayMatch = yamlContent.match(arrayTagRegex);
      if (arrayMatch) {
        const tagsStr = arrayMatch[1];
        const tagList = tagsStr.match(/"([^"]+)"/g);
        if (tagList) {
          tagList.forEach(tag => {
            tags.add(tag.replace(/"/g, '').startsWith('#') ? tag.replace(/"/g, '') : '#' + tag.replace(/"/g, ''));
          });
        }
      }

      // Match tags: list format
      const listTagRegex = /^-\s*(.+)$/gm;
      let listMatch;
      const inTagsSection = yamlContent.includes('tags:');
      if (inTagsSection) {
        const lines = yamlContent.split('\n');
        let inTags = false;
        for (const line of lines) {
          if (line.trim() === 'tags:') {
            inTags = true;
            continue;
          }
          if (inTags) {
            if (line.startsWith('- ')) {
              const tag = line.replace(/^\s*-\s*/, '').trim();
              tags.add(tag.startsWith('#') ? tag : '#' + tag);
            } else if (line.match(/^\w+:/)) {
              break; // Next YAML section
            }
          }
        }
      }
    }

    return Array.from(tags);
  }
```

**Step 2: Commit**

```bash
git add src/NoteFilter.ts
git commit -m "feat: add tag extraction from file content and frontmatter"
```

### Task 4: Implement Tag Filtering

**Files:**
- Modify: `src/NoteFilter.ts`

**Step 1: Add method to check if file matches tag filters**

Add to NoteFilter class:

```typescript
  // Check if file's tags match the filter criteria
  matchesTagFilters(tags: string[]): boolean {
    // Must not have any excluded tags
    const hasExcludedTag = this.settings.excludeTags.some(excludedTag =>
      tags.includes(excludedTag)
    );
    if (hasExcludedTag) return false;

    // If includeTags is set, must have at least one included tag
    if (this.settings.includeTags.length > 0) {
      const hasIncludedTag = this.settings.includeTags.some(includedTag =>
        tags.includes(includedTag)
      );
      if (!hasIncludedTag) return false;
    }

    return true;
  }
```

**Step 2: Commit**

```bash
git add src/NoteFilter.ts
git commit -m "feat: add tag filtering logic"
```

### Task 5: Implement Main Filter Method with Performance Optimization

**Files:**
- Modify: `src/NoteFilter.ts`

**Step 1: Add Fisher-Yates shuffle and main filter method**

Add to NoteFilter class:

```typescript
  // Fisher-Yates shuffle algorithm
  private shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  // Get filtered notes for review
  async getNotesForReview(): Promise<TFile[]> {
    // Step 1: Get all markdown files
    const allFiles = this.vault.getMarkdownFiles();

    // Step 2: Filter by time range and excluded folders (no content read)
    let candidates = allFiles.filter(file =>
      this.isInTimeRange(file) &&
      !this.isExcludedFolder(file)
    );

    // Step 3: Shuffle and take candidates (2x buffer for tag filtering)
    candidates = this.shuffleArray(candidates);
    const bufferSize = this.settings.reviewCount * 2;
    const candidateFiles = candidates.slice(0, bufferSize);

    // Step 4: Read content and filter by tags (only for candidates)
    const validFiles: TFile[] = [];
    for (const file of candidateFiles) {
      const tags = await this.getTagsFromFile(file);
      if (this.matchesTagFilters(tags)) {
        validFiles.push(file);
      }
      if (validFiles.length >= this.settings.reviewCount) {
        break;
      }
    }

    return validFiles;
  }
```

**Step 2: Export the complete class**

Ensure the file exports properly:

```typescript
export { NoteFilter };
```

**Step 3: Commit**

```bash
git add src/NoteFilter.ts
git commit -m "feat: add main filtering method with performance optimization"
```

---

## Module 3: Settings UI

### Task 6: Create Settings Tab

**Files:**
- Create: `src/Settings.ts`

**Step 1: Create the Settings class**

```typescript
import { App, PluginSettingTab, Setting } from "obsidian";
import DailyReviewPlugin from "./main";
import { DailyReviewSettings, DEFAULT_SETTINGS } from "./types";

export class DailyReviewSettingTab extends PluginSettingTab {
  plugin: DailyReviewPlugin;

  constructor(app: App, plugin: DailyReviewPlugin) {
    super(app, plugin);
    this.plugin = plugin;
  }

  display(): void {
    const { containerEl } = this;
    containerEl.empty();

    // Header
    containerEl.createEl('h2', { text: 'Daily Review Settings' });

    // Time Range Setting
    new Setting(containerEl)
      .setName('Time Range')
      .setDesc('Select the time range for notes to review')
      .addDropdown(dropdown => dropdown
        .addOption('today', 'Today')
        .addOption('week', 'Last Week')
        .addOption('month', 'Last Month')
        .addOption('quarter', 'Last Quarter')
        .addOption('all', 'All Time')
        .setValue(this.plugin.settings.timeRange)
        .onChange(async (value: DailyReviewSettings['timeRange']) => {
          this.plugin.settings.timeRange = value;
          await this.plugin.saveSettings();
        }));

    // Review Count Setting
    new Setting(containerEl)
      .setName('Review Count')
      .setDesc('Number of notes to review per session')
      .addText(text => text
        .setPlaceholder('10')
        .setValue(String(this.plugin.settings.reviewCount))
        .onChange(async (value) => {
          const num = parseInt(value);
          if (!isNaN(num) && num > 0) {
            this.plugin.settings.reviewCount = num;
            await this.plugin.saveSettings();
          }
        }));

    // Include Tags Setting
    this.addTagListSetting(
      containerEl,
      'Include Tags',
      'Only include notes with these tags (leave empty to include all)',
      'includeTags',
      'Add include tag...'
    );

    // Exclude Tags Setting
    this.addTagListSetting(
      containerEl,
      'Exclude Tags',
      'Exclude notes with these tags',
      'excludeTags',
      'Add exclude tag...'
    );

    // Exclude Folders Setting
    this.addFolderListSetting(
      containerEl,
      'Exclude Folders',
      'Exclude notes in these folders',
      'excludeFolders',
      'Add folder path...'
    );

    // Include Subfolders Setting
    new Setting(containerEl)
      .setName('Include Subfolders')
      .setDesc('When filtering by folder, include subfolders')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.includeSubfolders)
        .onChange(async (value) => {
          this.plugin.settings.includeSubfolders = value;
          await this.plugin.saveSettings();
        }));
  }

  private addTagListSetting(
    containerEl: HTMLElement,
    name: string,
    desc: string,
    settingKey: 'includeTags' | 'excludeTags',
    placeholder: string
  ): void {
    const setting = new Setting(containerEl)
      .setName(name)
      .setDesc(desc);

    // Create container for tag list
    const tagListContainer = createEl('div', {
      cls: 'daily-review-tag-list'
    });

    setting.settingEl.appendChild(tagListContainer);

    // Render existing tags
    const renderTags = () => {
      tagListContainer.empty();
      this.plugin.settings[settingKey].forEach((tag, index) => {
        const tagEl = tagListContainer.createEl('div', {
          cls: 'daily-review-tag-item'
        });

        tagEl.createSpan({ text: tag, cls: 'daily-review-tag-text' });

        const removeBtn = tagEl.createEl('button', {
          text: 'Ã—',
          cls: 'daily-review-tag-remove'
        });
        removeBtn.onclick = async () => {
          this.plugin.settings[settingKey].splice(index, 1);
          await this.plugin.saveSettings();
          renderTags();
        };
      });
    };

    // Add new tag input
    const inputEl = createEl('input', {
      type: 'text',
      placeholder: placeholder
    });
    inputEl.addClass('daily-review-tag-input');

    const addBtn = createEl('button', {
      text: 'Add'
    });

    const handleAdd = async () => {
      const value = inputEl.value.trim();
      if (value && !this.plugin.settings[settingKey].includes(value)) {
        // Auto-add # if not present
        const tag = value.startsWith('#') ? value : '#' + value;
        this.plugin.settings[settingKey].push(tag);
        await this.plugin.saveSettings();
        inputEl.value = '';
        renderTags();
      }
    };

    addBtn.onclick = handleAdd;
    inputEl.onkeypress = (e) => {
      if (e.key === 'Enter') handleAdd();
    };

    setting.controls.appendChild(inputEl);
    setting.controls.appendChild(addBtn);

    renderTags();
  }

  private addFolderListSetting(
    containerEl: HTMLElement,
    name: string,
    desc: string,
    settingKey: 'excludeFolders',
    placeholder: string
  ): void {
    const setting = new Setting(containerEl)
      .setName(name)
      .setDesc(desc);

    // Create container for folder list
    const folderListContainer = createEl('div', {
      cls: 'daily-review-folder-list'
    });

    setting.settingEl.appendChild(folderListContainer);

    // Render existing folders
    const renderFolders = () => {
      folderListContainer.empty();
      this.plugin.settings[settingKey].forEach((folder, index) => {
        const folderEl = folderListContainer.createEl('div', {
          cls: 'daily-review-folder-item'
        });

        folderEl.createSpan({ text: folder, cls: 'daily-review-folder-text' });

        const removeBtn = folderEl.createEl('button', {
          text: 'Ã—',
          cls: 'daily-review-folder-remove'
        });
        removeBtn.onclick = async () => {
          this.plugin.settings[settingKey].splice(index, 1);
          await this.plugin.saveSettings();
          renderFolders();
        };
      });
    };

    // Add new folder input
    const inputEl = createEl('input', {
      type: 'text',
      placeholder: placeholder
    });
    inputEl.addClass('daily-review-folder-input');

    const addBtn = createEl('button', {
      text: 'Add'
    });

    const handleAdd = async () => {
      const value = inputEl.value.trim();
      if (value && !this.plugin.settings[settingKey].includes(value)) {
        this.plugin.settings[settingKey].push(value);
        await this.plugin.saveSettings();
        inputEl.value = '';
        renderFolders();
      }
    };

    addBtn.onclick = handleAdd;
    inputEl.onkeypress = (e) => {
      if (e.key === 'Enter') handleAdd();
    };

    setting.controls.appendChild(inputEl);
    setting.controls.appendChild(addBtn);

    renderFolders();
  }
}
```

**Step 2: Commit**

```bash
git add src/Settings.ts
git commit -m "feat: add settings tab UI"
```

---

## Module 4: Review Modal

### Task 7: Create Review Modal

**Files:**
- Create: `src/ReviewModal.ts`

**Step 1: Create the ReviewModal class**

```typescript
import { App, Modal, TFile, Notice } from "obsidian";

export class ReviewModal extends Modal {
  private files: TFile[];
  private currentIndex: number = 0;
  private markedAsRead: Set<number> = new Set();

  constructor(
    app: App,
    files: TFile[]
  ) {
    super(app);
    this.files = files;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('daily-review-modal');

    // Header
    const header = contentEl.createDiv('daily-review-header');
    header.createEl('h2', { text: 'Daily Review' });

    // Progress display
    const progressEl = header.createDiv('daily-review-progress');

    // Content container
    const noteContainer = contentEl.createDiv('daily-review-note-container');

    // Action buttons
    const actionContainer = contentEl.createDiv('daily-review-actions');

    // Navigation buttons
    const navContainer = contentEl.createDiv('daily-review-navigation');

    // Render first note
    this.renderNote();

    // Handle modal close
    this.onClose = () => {
      contentEl.empty();
    };
  }

  private renderNote() {
    const { contentEl } = this;

    // Clear existing content
    const existingNote = contentEl.querySelector('.daily-review-note-container');
    if (existingNote) {
      existingNote.empty();
    }

    const existingProgress = contentEl.querySelector('.daily-review-progress');
    if (existingProgress) {
      existingProgress.empty();
    }

    // Check if all notes reviewed or marked as read
    const availableNotes = this.files.filter((_, i) => !this.markedAsRead.has(i));

    if (availableNotes.length === 0) {
      this.showCompleteMessage();
      return;
    }

    // Find next unmarked note
    while (this.markedAsRead.has(this.currentIndex)) {
      this.currentIndex = (this.currentIndex + 1) % this.files.length;
    }

    const file = this.files[this.currentIndex];

    // Update progress
    const progressEl = contentEl.querySelector('.daily-review-progress') as HTMLElement;
    if (progressEl) {
      progressEl.setText(`${this.currentIndex + 1} / ${this.files.length}`);
    }

    // Render note
    const noteContainer = contentEl.querySelector('.daily-review-note-container') as HTMLElement;
    if (noteContainer) {
      // Note header
      const noteHeader = noteContainer.createDiv('daily-review-note-header');

      noteHeader.createEl('h3', {
        text: file.basename,
        cls: 'daily-review-note-title'
      });

      const metaInfo = noteHeader.createDiv('daily-review-note-meta');
      metaInfo.createSpan({ text: `ðŸ“ ${file.path}` });

      // Read tags
      this.app.vault.read(file).then(content => {
        const tags = this.extractTags(content);
        if (tags.length > 0) {
          const tagEl = metaInfo.createSpan({ text: ' ðŸ·ï¸ ' });
          tags.forEach(tag => {
            tagEl.createSpan({ text: tag, cls: 'daily-review-tag' });
          });
        }
      });

      // Note content
      const noteContent = noteContainer.createDiv('daily-review-note-content');

      this.app.vault.read(file).then(content => {
        noteContent.setText(content);
      });
    }

    // Update action buttons
    this.renderActions();

    // Update navigation buttons
    this.renderNavigation();
  }

  private extractTags(content: string): string[] {
    const tags = new Set<string>();

    // Inline tags
    const inlineTagRegex = /(?<!\w)#([\p{L}\p{N}_-]+)/gu;
    let match;
    while ((match = inlineTagRegex.exec(content)) !== null) {
      tags.add('#' + match[1]);
    }

    return Array.from(tags);
  }

  private renderActions() {
    const { contentEl } = this;
    let actionContainer = contentEl.querySelector('.daily-review-actions') as HTMLElement;

    if (!actionContainer) {
      actionContainer = contentEl.createDiv('daily-review-actions');
    } else {
      actionContainer.empty();
    }

    // Open in main window button
    const openBtn = actionContainer.createEl('button', {
      text: 'Open in Main',
      cls: 'mod-cta'
    });
    openBtn.onclick = () => {
      this.openInMainWindow();
    };

    // Mark as read button
    const markBtn = actionContainer.createEl('button', {
      text: 'Mark as Read'
    });
    markBtn.onclick = () => {
      this.markAsRead();
    };
  }

  private renderNavigation() {
    const { contentEl } = this;
    let navContainer = contentEl.querySelector('.daily-review-navigation') as HTMLElement;

    if (!navContainer) {
      navContainer = contentEl.createDiv('daily-review-navigation');
    } else {
      navContainer.empty();
    }

    // Previous button
    const prevBtn = navContainer.createEl('button', { text: 'â† Previous' });
    prevBtn.onclick = () => {
      this.navigatePrevious();
    };

    // Next button
    const nextBtn = navContainer.createEl('button', { text: 'Next â†’' });
    nextBtn.onclick = () => {
      this.navigateNext();
    };
  }

  private openInMainWindow() {
    const file = this.files[this.currentIndex];
    this.app.workspace.openLinkText(file.path, '', true);
    this.close();
  }

  private markAsRead() {
    this.markedAsRead.add(this.currentIndex);
    new Notice('Marked as read');
    this.navigateNext();
  }

  private navigatePrevious() {
    do {
      this.currentIndex = (this.currentIndex - 1 + this.files.length) % this.files.length;
    } while (this.markedAsRead.has(this.currentIndex) && this.hasAvailableNotes());
    this.renderNote();
  }

  private navigateNext() {
    do {
      this.currentIndex = (this.currentIndex + 1) % this.files.length;
    } while (this.markedAsRead.has(this.currentIndex) && this.hasAvailableNotes());
    this.renderNote();
  }

  private hasAvailableNotes(): boolean {
    return this.files.some((_, i) => !this.markedAsRead.has(i));
  }

  private showCompleteMessage() {
    const { contentEl } = this;
    const existingNote = contentEl.querySelector('.daily-review-note-container');
    if (existingNote) {
      existingNote.empty();
    }

    const existingProgress = contentEl.querySelector('.daily-review-progress');
    if (existingProgress) {
      existingProgress.empty();
    }

    let actionContainer = contentEl.querySelector('.daily-review-actions') as HTMLElement;
    if (actionContainer) {
      actionContainer.empty();
    }

    let navContainer = contentEl.querySelector('.daily-review-navigation') as HTMLElement;
    if (navContainer) {
      navContainer.empty();
    }

    const completeMsg = contentEl.createEl('div', {
      cls: 'daily-review-complete'
    });
    completeMsg.createEl('h3', { text: 'Review Complete!' });
    completeMsg.createEl('p', { text: 'You\'ve reviewed all notes in this session.' });
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}
```

**Step 2: Commit**

```bash
git add src/ReviewModal.ts
git commit -m "feat: add ReviewModal with single-note focus"
```

---

## Module 5: Main Plugin Integration

### Task 8: Update Main Plugin File

**Files:**
- Modify: `main.ts`

**Step 1: Replace main.ts with complete implementation**

```typescript
import { Plugin, Notice } from 'obsidian';
import { DailyReviewSettings, DEFAULT_SETTINGS } from './src/types';
import { NoteFilter } from './src/NoteFilter';
import { ReviewModal } from './src/ReviewModal';
import { DailyReviewSettingTab } from './src/Settings';

export default class DailyReviewPlugin extends Plugin {
  settings: DailyReviewSettings;

  async onload() {
    console.log('Loading Daily Review plugin');

    // Load settings
    await this.loadSettings();

    // Add ribbon icon
    this.addRibbonIcon('dice', 'Daily Review', () => {
      this.startReview();
    });

    // Add command
    this.addCommand({
      id: 'start-review',
      name: 'Start Review',
      callback: () => {
        this.startReview();
      },
    });

    // Add settings tab
    this.addSettingTab(new DailyReviewSettingTab(this.app, this));
  }

  onunload() {
    console.log('Unloading Daily Review plugin');
  }

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }

  async startReview() {
    const filter = new NoteFilter(this.app.vault, this.settings);
    const notes = await filter.getNotesForReview();

    if (notes.length === 0) {
      new Notice('No notes found matching your criteria. Check your settings.');
      return;
    }

    new ReviewModal(this.app, notes).open();
  }
}
```

**Step 2: Commit**

```bash
git add main.ts
git commit -m "feat: integrate all modules into main plugin"
```

---

## Module 6: Styles

### Task 9: Add CSS Styles

**Files:**
- Create: `styles.css`

**Step 1: Create styles.css**

```css
/* Modal Container */
.daily-review-modal {
  padding: 0;
  max-width: 100%;
}

/* Header */
.daily-review-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 1.5rem;
  border-bottom: 1px solid var(--background-modifier-border);
}

.daily-review-header h2 {
  margin: 0;
  font-size: 1.5rem;
}

.daily-review-progress {
  font-size: 0.9rem;
  color: var(--text-muted);
}

/* Note Container */
.daily-review-note-container {
  max-height: 60vh;
  overflow-y: auto;
  padding: 1.5rem;
}

/* Note Header */
.daily-review-note-header {
  margin-bottom: 1rem;
}

.daily-review-note-title {
  margin: 0 0 0.5rem 0;
  font-size: 1.3rem;
}

.daily-review-note-meta {
  font-size: 0.85rem;
  color: var(--text-muted);
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.daily-review-tag {
  background: var(--background-modifier-border);
  padding: 0.1rem 0.4rem;
  border-radius: 4px;
  font-size: 0.8rem;
}

/* Note Content */
.daily-review-note-content {
  white-space: pre-wrap;
  word-wrap: break-word;
  line-height: 1.6;
  font-size: 0.95rem;
}

/* Action Buttons */
.daily-review-actions {
  display: flex;
  justify-content: center;
  gap: 1rem;
  padding: 1rem;
  border-top: 1px solid var(--background-modifier-border);
}

.daily-review-actions button {
  flex: 1;
  max-width: 200px;
}

/* Navigation */
.daily-review-navigation {
  display: flex;
  justify-content: space-between;
  padding: 1rem 1.5rem;
  border-top: 1px solid var(--background-modifier-border);
}

/* Complete Message */
.daily-review-complete {
  text-align: center;
  padding: 3rem;
}

.daily-review-complete h3 {
  margin-bottom: 1rem;
}

/* Settings UI */
.daily-review-tag-list,
.daily-review-folder-list {
  margin-bottom: 0.5rem;
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.daily-review-tag-item,
.daily-review-folder-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: var(--background-secondary);
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
}

.daily-review-tag-remove,
.daily-review-folder-remove {
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 1.2rem;
  line-height: 1;
  padding: 0;
  width: auto;
}

.daily-review-tag-remove:hover,
.daily-review-folder-remove:hover {
  color: var(--text-normal);
}

.daily-review-tag-input,
.daily-review-folder-input {
  margin-right: 0.5rem;
  padding: 0.25rem 0.5rem;
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  background: var(--background-primary);
  color: var(--text-normal);
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .daily-review-modal {
    width: 100% !important;
    height: 100% !important;
    max-height: 100vh;
  }

  .daily-review-note-container {
    max-height: calc(100vh - 200px);
  }

  .daily-review-actions {
    flex-direction: column;
  }

  .daily-review-actions button {
    max-width: 100%;
  }
}
```

**Step 2: Update main.ts to load styles**

Add this to the `onload` method in main.ts:

```typescript
// Load styles
this.loadStyles();
```

**Step 3: Commit**

```bash
git add styles.css main.ts
git commit -m "feat: add CSS styles with mobile responsive design"
```

---

## Module 7: Final Integration & Testing

### Task 10: Build and Test

**Step 1: Build the plugin**

```bash
npm run build
```

Expected: No errors, main.js generated

**Step 2: Verify file structure**

```bash
ls -la
```

Expected: main.ts, main.js, styles.css, manifest.json, src/ directory

**Step 3: Test in Obsidian**

Manual testing steps:
1. Copy plugin folder to Obsidian vault plugins directory
2. Enable plugin in Obsidian settings
3. Open settings and configure:
   - Time range
   - Review count
   - Tags to include/exclude
   - Folders to exclude
4. Click ribbon icon to open review modal
5. Test navigation (previous/next)
6. Test "Open in Main" button
7. Test "Mark as Read" button
8. Test with empty result set
9. Test on mobile (if available)

**Step 4: Fix any issues found during testing**

(Commit fixes separately)

**Step 5: Final commit**

```bash
git add .
git commit -m "feat: complete Daily Review plugin implementation"
```

---

## Summary

This implementation plan creates a complete Obsidian plugin for daily note review with:

1. **Type-safe TypeScript** with clear interfaces
2. **Performance-optimized filtering** - only reads content for candidate notes
3. **Mobile-friendly UI** - native Modal with responsive design
4. **Flexible configuration** - time range, tags, folders
5. **Single-note focus** - clean, distraction-free review experience

**Total estimated tasks:** 10
**Estimated time:** 2-3 hours for implementation
